import streamlit as st
import requests
from openai import OpenAI
import json
import random
import os

# Initialize OpenAI client
api_key = os.getenv("OPENAI_API_KEY")

client = OpenAI(api_key=api_key)

POKEAPI_BASE = "https://pokeapi.co/api/v2"

def get_random_pokemon(num=151):
    """Return a random Pok√©mon from the first 151"""
    poke_id = random.randint(1, num)
    r = requests.get(f"{POKEAPI_BASE}/pokemon/{poke_id}")
    if r.status_code != 200:
        return None
    data = r.json()
    return {
        "name": data["name"].capitalize(),
        "types": [t["type"]["name"] for t in data["types"]],
        "stats": {s["stat"]["name"]: s["base_stat"] for s in data["stats"]},
        "id": data["id"]
    }

def generate_quiz_question():
    """Generate a Pok√©mon quiz question using PokeAPI and OpenAI, safely handling JSON parsing."""
    correct_pokemon = get_random_pokemon()
    if not correct_pokemon:
        return None

    # Pick 3 random wrong options
    wrong_options = []
    while len(wrong_options) < 3:
        poke = get_random_pokemon()
        if poke and poke["name"] != correct_pokemon["name"] and poke["name"] not in wrong_options:
            wrong_options.append(poke["name"])
    
    options = wrong_options + [correct_pokemon["name"]]
    random.shuffle(options)

    # Strict JSON prompt
    prompt = f"""
You are a Pok√©mon Quizmaster.
Create a multiple-choice question with **one correct answer** and three wrong options.
Correct answer: {correct_pokemon['name']}
Options: {options}
Include a short hint about the Pok√©mon without giving away the answer.

**IMPORTANT: Return ONLY valid JSON with EXACT keys:**
- question (string)
- options (list of 4 strings)
- answer (string)
- hint (string)

Do not include any text outside the JSON.
"""

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7
        )
        content = response.choices[0].message.content.strip()

        # Attempt to parse JSON safely
        try:
            data = json.loads(content)
        except json.JSONDecodeError:
            # If JSON parse fails, try to extract JSON using regex (common trick)
            import re
            match = re.search(r"\{.*\}", content, re.DOTALL)
            if match:
                data = json.loads(match.group())
            else:
                raise ValueError("Failed to parse JSON from model output.")

        # Add Pok√©mon ID for image
        data["pokemon_id"] = correct_pokemon["id"]
        return data

    except Exception as e:
        print(f"OpenAI API failed or JSON invalid: {e}")
        # fallback question
        return {
            "question": f"Which Pok√©mon is {correct_pokemon['name']}?",
            "options": options,
            "answer": correct_pokemon["name"],
            "hint": f"It has type(s): {', '.join(correct_pokemon['types'])}",
            "pokemon_id": correct_pokemon["id"]
        }


# -----------------------------
# Streamlit UI
# -----------------------------
st.set_page_config(page_title="Pok√©mon Quizmaster", page_icon=":zap:")

st.title("Pok√©mon Quizmaster Agent")
st.write("Answer fun Pok√©mon quiz questions generated by an AI using real Pok√©mon data!")

# Initialize session state
if "score" not in st.session_state:
    st.session_state.score = 0
if "quiz" not in st.session_state:
    st.session_state.quiz = generate_quiz_question()
if "selected" not in st.session_state:
    st.session_state.selected = None
if "answered" not in st.session_state:
    st.session_state.answered = False

quiz = st.session_state.quiz

# # Show Pok√©mon image
# if "pokemon_id" in quiz:
#     st.image(f"https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/{quiz['pokemon_id']}.png", width=120)

# Show question
st.subheader("Question:")
st.write(quiz["question"])

# -----------------------------
# Option button callback
# -----------------------------
def answer_option(option):
    st.session_state.selected = option
    st.session_state.answered = True
    if option == quiz["answer"]:
        st.session_state.score += 1

# Show options as buttons
for option in quiz["options"]:
    st.button(option, on_click=answer_option, args=(option,))

# Show feedback if answered
if st.session_state.answered:
    if st.session_state.selected == quiz["answer"]:
        st.success("Correct!")
    else:
        st.error(f"Wrong! Correct answer: {quiz['answer']}")
    st.write(f"üí° Hint: {quiz['hint']}")

    # -----------------------------
    # Next question callback
    # -----------------------------
    def next_question():
        st.session_state.quiz = generate_quiz_question()
        st.session_state.selected = None
        st.session_state.answered = False

    st.button("Next Question", on_click=next_question)

# Show score
st.write(f"Score: {st.session_state.score}")
